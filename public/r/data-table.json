{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table",
  "type": "registry:component",
  "title": "Data Table",
  "description": "A reusable data table component that allows for grouping, footers, and secondary rows",
  "dependencies": [
    "lucide-react",
    "clsx",
    "tailwind-merge",
    "class-variance-authority"
  ],
  "files": [
    {
      "path": "registry/new-york/data-table/data-table-body-row.tsx",
      "content": "import type {\n   StyleOptions,\n   ColumnDef,\n} from \"@/registry/new-york/data-table/data-table-types\";\nimport { cn } from \"@/lib/utils\";\n\nexport function TableBodyRow<T extends object>({\n   row,\n   appearance,\n   columns,\n   index,\n   secondaryRowRender,\n}: {\n   row: T;\n   appearance?: StyleOptions;\n   columns: ColumnDef<T>[];\n   index: number;\n   secondaryRowRender?: (row: T) => React.ReactNode;\n}) {\n   return (\n      <>\n         <tr\n            className={cn(\n               appearance?.bodyRow,\n               index % 2 === 0\n                  ? appearance?.bodyEvenRow\n                  : appearance?.bodyOddRow\n            )}\n         >\n            {columns.map((c) => (\n               <td\n                  key={c.accessorKey as string}\n                  className={cn(\n                     \"justify-self-center align-middle\",\n                     appearance?.bodyCell,\n                     c.cellClassName\n                  )}\n                  style={{\n                     padding: appearance?.cellPadding,\n                     textAlign: c.align,\n                  }}\n               >\n                  {c.cell ? c.cell({ row }) : <>{row[c.accessorKey]}</>}\n               </td>\n            ))}\n         </tr>\n         {secondaryRowRender !== undefined &&\n            secondaryRowRender(row) !== null && (\n               <tr className={appearance?.secondaryRow}>\n                  <td\n                     colSpan={columns.length}\n                     className={appearance?.secondaryCell}\n                     style={{ padding: appearance?.cellPadding }}\n                  >\n                     {secondaryRowRender(row)}\n                  </td>\n               </tr>\n            )}\n      </>\n   );\n}\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-body-row.tsx"
    },
    {
      "path": "registry/new-york/data-table/data-table-header.tsx",
      "content": "import type {\n   StyleOptions,\n   ColumnDef,\n} from \"@/registry/new-york/data-table/data-table-types\";\nimport { cn } from \"@/lib/utils\";\nimport { ArrowDownIcon, ArrowUpIcon } from \"lucide-react\";\nimport { capitalize } from \"@/registry/new-york/data-table/text-utils\";\n\nexport const TableHeader = <T extends object>({\n   columns,\n   appearance,\n   toggleSort,\n   getSortDirection,\n}: {\n   columns: ColumnDef<T>[];\n   appearance?: StyleOptions;\n   toggleSort: (column: keyof T) => void;\n   getSortDirection: (column: keyof T) => { dir: \"asc\" | \"desc\" } | undefined;\n}) => {\n   return (\n      <thead>\n         <tr className={appearance?.headerRow}>\n            {columns.map((c) => {\n               const sortDirection = getSortDirection(c.accessorKey)?.dir;\n               const isSorted = !!sortDirection;\n\n               return (\n                  <th\n                     key={c.accessorKey as string}\n                     style={{\n                        width: c.size ? `${c.size}px` : undefined,\n                        padding: appearance?.cellPadding,\n                     }}\n                     className={appearance?.headerCell}\n                  >\n                     <div\n                        className={cn(\n                           \"group flex w-full items-center\",\n                           c.headerClassName\n                        )}\n                        style={{ justifyContent: c.align ? c.align : \"left\" }}\n                     >\n                        {c.header ?? capitalize(c.accessorKey as string)}\n                        {c.sortable && (\n                           <button\n                              onClick={() => toggleSort(c.accessorKey)}\n                              type=\"button\"\n                              className={cn(\n                                 \"ml-1 h-full rounded-lg p-0.25 hover:bg-white/70 dark:hover:bg-white/20 [&_svg]:size-4\",\n                                 !isSorted &&\n                                    \"opacity-0 group-hover:opacity-100\",\n                                 c.sortButtonClassName\n                              )}\n                           >\n                              {sortDirection !== \"desc\" && <ArrowDownIcon />}\n                              {sortDirection === \"desc\" && <ArrowUpIcon />}\n                           </button>\n                        )}\n                     </div>\n                  </th>\n               );\n            })}\n         </tr>\n      </thead>\n   );\n};\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-header.tsx"
    },
    {
      "path": "registry/new-york/data-table/data-table-body.tsx",
      "content": "import type {\n   ColumnDef,\n   FooterRenderer,\n   GroupByRenderer,\n   SecondaryRowRenderer,\n   StyleOptions,\n} from \"@/registry/new-york/data-table/data-table-types\";\nimport { cn } from \"@/lib/utils\";\nimport { TableBodyRow } from \"./data-table-body-row\";\nimport { Fragment } from \"react\";\n\nexport const TableBody = <T extends object>({\n   columns,\n   groupByData,\n   rows,\n   groupByRenderer,\n   secondaryRowRenderer,\n   footerRenderer,\n   appearance,\n}: {\n   columns: ColumnDef<T>[];\n   groupByData?: [string, T[]][];\n   rows: T[];\n   groupByRenderer?: GroupByRenderer<T>;\n   secondaryRowRenderer?: SecondaryRowRenderer<T>;\n   footerRenderer?: FooterRenderer<T>;\n   appearance?: StyleOptions;\n}) => {\n   const isEmpty = rows.length === 0;\n   return (\n      <tbody>\n         {!isEmpty && groupByData && (\n            <GroupByBody<T>\n               columns={columns}\n               groupByData={groupByData}\n               groupByRenderer={groupByRenderer}\n               appearance={appearance}\n            />\n         )}\n         {!isEmpty &&\n            !groupByData &&\n            rows.map((row, index) => (\n               <TableBodyRow\n                  key={index}\n                  index={index}\n                  columns={columns}\n                  appearance={appearance}\n                  row={row}\n                  secondaryRowRender={secondaryRowRenderer}\n               />\n            ))}\n         {!isEmpty && footerRenderer && (\n            <Footer\n               columns={columns}\n               appearance={appearance}\n               rows={rows}\n               footerRenderer={footerRenderer}\n            />\n         )}\n         {isEmpty && (\n            <tr className={appearance?.bodyRow}>\n               <td\n                  colSpan={columns.length}\n                  className={cn(\"text-lg font-medium\", appearance?.bodyCell)}\n                  style={{ padding: 50, textAlign: \"center\" }}\n               >\n                  No Results\n               </td>\n            </tr>\n         )}\n      </tbody>\n   );\n};\n\nconst Footer = <T extends object>({\n   columns,\n   rows,\n   footerRenderer,\n   appearance,\n}: {\n   columns: ColumnDef<T>[];\n   rows: T[];\n   footerRenderer?: FooterRenderer<T>;\n   appearance?: StyleOptions;\n}) => {\n   if (!footerRenderer) {\n      return null;\n   }\n   const FooterColumns = footerRenderer(rows).map((cell, index) => (\n      <td\n         key={index}\n         className={cn(appearance?.footerCell, cell.className)}\n         style={{ padding: appearance?.cellPadding }}\n      >\n         {cell.node}\n      </td>\n   ));\n   while (FooterColumns.length < columns.length) {\n      FooterColumns.push(\n         <td\n            key={FooterColumns.length + 1}\n            className={appearance?.footerCell}\n            style={{ padding: appearance?.cellPadding }}\n         ></td>\n      );\n   }\n   return <tr className={appearance?.footerRow}>{FooterColumns}</tr>;\n};\n\nconst GroupByBody = <T extends object>({\n   groupByData,\n   columns,\n   groupByRenderer,\n   appearance,\n   secondaryRowRenderer,\n}: {\n   groupByData: [string, T[]][];\n   columns: ColumnDef<T>[];\n   groupByRenderer?: GroupByRenderer<T>;\n   appearance?: StyleOptions;\n   secondaryRowRenderer?: SecondaryRowRenderer<T>;\n}) => {\n   return (\n      <>\n         {groupByData?.map(([key, values]) => (\n            <Fragment key={key}>\n               <GroupByHeader\n                  groupByKey={key}\n                  values={values}\n                  columns={columns}\n                  groupByRenderer={groupByRenderer}\n                  appearance={appearance}\n               />\n               {values.map((row, index) => {\n                  return (\n                     <TableBodyRow\n                        key={index}\n                        index={index}\n                        columns={columns}\n                        appearance={appearance}\n                        row={row}\n                        secondaryRowRender={secondaryRowRenderer}\n                     />\n                  );\n               })}\n            </Fragment>\n         ))}\n      </>\n   );\n};\n\nconst GroupByHeader = <T extends object>({\n   groupByKey,\n   values,\n   columns,\n   groupByRenderer,\n   appearance,\n}: {\n   groupByKey: string;\n   values: T[];\n   columns: ColumnDef<T>[];\n   groupByRenderer?: GroupByRenderer<T>;\n   appearance?: StyleOptions;\n}) => {\n   let HeaderColumns = [\n      <td\n         key={groupByKey}\n         colSpan={columns.length}\n         className={appearance?.groupByCell}\n         style={{ padding: appearance?.cellPadding }}\n      >\n         {groupByKey}\n      </td>,\n   ];\n\n   if (groupByRenderer) {\n      HeaderColumns = groupByRenderer(groupByKey as keyof T, values).map(\n         (node, index) => (\n            <td\n               key={index}\n               className={cn(appearance?.groupByCell, node.className)}\n               style={{\n                  padding: appearance?.cellPadding,\n               }}\n            >\n               {node.node}\n            </td>\n         )\n      );\n      while (HeaderColumns.length < columns.length) {\n         HeaderColumns.push(\n            <td\n               key={HeaderColumns.length + 1}\n               className={cn(appearance?.groupByCell)}\n               style={{\n                  padding: appearance?.cellPadding,\n               }}\n            ></td>\n         );\n      }\n   }\n\n   return <tr className={appearance?.groupByRow}>{HeaderColumns}</tr>;\n};\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-body.tsx"
    },
    {
      "path": "registry/new-york/data-table/use-data-table.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport { TableBody } from \"@/registry/new-york/data-table/data-table-body\";\nimport { TableHeader } from \"@/registry/new-york/data-table/data-table-header\";\nimport type {\n   ColumnDef,\n   FooterRenderer,\n   GroupByRenderer,\n   SecondaryRowRenderer,\n   StyleOptions,\n} from \"@/registry/new-york/data-table/data-table-types\";\nimport { useData } from \"@/registry/new-york/data-table/use-data\";\nimport { useFilters } from \"@/registry/new-york/data-table/use-filters\";\nimport { useSorting } from \"@/registry/new-york/data-table/use-sorting\";\n\nexport function useDataTable<T extends object>({\n   columns,\n   data,\n   secondaryRowRenderer,\n   groupBy,\n   groupByRenderer,\n   appearance,\n   footerRenderer,\n   initialSortColumn,\n}: {\n   appearance?: StyleOptions;\n   columns: ColumnDef<T>[];\n   data: T[];\n   groupBy?: keyof T;\n   groupByRenderer?: GroupByRenderer<T>;\n   secondaryRowRenderer?: SecondaryRowRenderer<T>;\n   footerRenderer?: FooterRenderer<T>;\n   initialSortColumn?: keyof T;\n}) {\n   const { getFilter, setFilter, filters } = useFilters<T>();\n   const { sortColumn, toggleSort, getSortDirection } =\n      useSorting<T>(initialSortColumn);\n   const { rows, groupedByData } = useData({\n      data,\n      filters,\n      sortColumn,\n      columns,\n      groupBy,\n   });\n\n   const DataTable = () => (\n      <div\n         className={cn(\n            \"mb-5 overflow-x-auto rounded-lg border\",\n            appearance?.container\n         )}\n      >\n         <table className={cn(\"w-full border-spacing-0\", appearance?.table)}>\n            <TableHeader\n               columns={columns}\n               appearance={appearance}\n               getSortDirection={getSortDirection}\n               toggleSort={toggleSort}\n            />\n            <TableBody\n               columns={columns}\n               groupByData={groupedByData}\n               rows={rows}\n               groupByRenderer={groupByRenderer}\n               secondaryRowRenderer={secondaryRowRenderer}\n               footerRenderer={footerRenderer}\n               appearance={appearance}\n            />\n         </table>\n      </div>\n   );\n\n   return {\n      toggleSort,\n      setFilter,\n      DataTable,\n      getFilter,\n   };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/data-table/use-data.ts",
      "content": "import type { ColumnDef } from \"@/registry/new-york/data-table/data-table-types\";\nimport {\n   defaultFilterFn,\n   defaultSortFn,\n   doGroupBy,\n   startsWithFilterFn,\n} from \"@/registry/new-york/data-table/data-table-utils\";\nimport { useMemo } from \"react\";\n\nexport const useData = <T extends object, K extends keyof T = keyof T>({\n   data,\n   filters,\n   sortColumn,\n   columns,\n   groupBy,\n}: {\n   data: T[];\n   filters?: Record<K, T[K]>;\n   sortColumn?: [K, \"asc\" | \"desc\"];\n   columns: ColumnDef<T>[];\n   groupBy?: K;\n}) => {\n   const rows = useMemo(() => {\n      let rows = data.map((row) => ({ ...row }));\n\n      if (filters) {\n         const activeFilters = Object.entries(filters).map(([key, value]) => {\n            const columnDef = columns.find(\n               (column) => column.accessorKey === key\n            );\n            const columnFilterFn = columnDef?.filterFn;\n            let filterFn: (value: T[K], filter: T[K]) => boolean =\n               defaultFilterFn;\n            if (columnFilterFn && typeof columnFilterFn === \"string\") {\n               filterFn = (a: T[K], filter: T[K]) =>\n                  startsWithFilterFn(String(a), String(filter));\n            } else if (columnFilterFn !== undefined) {\n               filterFn = defaultFilterFn;\n            }\n\n            return {\n               key: key as K,\n               fn: filterFn,\n               value: value as T[K],\n            };\n         });\n\n         if (activeFilters.length > 0) {\n            rows = rows.filter((row) => {\n               for (const { key, fn, value } of activeFilters) {\n                  if (!fn(row[key], value)) {\n                     return false;\n                  }\n               }\n               return true;\n            });\n         }\n\n         return rows;\n      }\n\n      if (sortColumn) {\n         const columnDef = columns.find(\n            (column) => column.accessorKey === sortColumn[0]\n         );\n         const sortFn = columnDef?.sortFn ?? defaultSortFn;\n         return rows.sort((a, b) => {\n            const sortDirection = sortColumn[1];\n            const key = sortColumn[0];\n            const aValue = a[key];\n            const bValue = b[key];\n            const order = sortFn(aValue, bValue);\n            if (sortDirection === \"asc\") {\n               return order;\n            }\n            return -order;\n         });\n      }\n\n      return rows;\n   }, [data, sortColumn, columns, filters]);\n\n   const groupedByData = useMemo(() => {\n      if (groupBy) {\n         return doGroupBy(rows, groupBy);\n      }\n      return undefined;\n   }, [groupBy, rows]);\n\n   return { rows, groupedByData };\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/data-table/use-filters.ts",
      "content": "import { omitFields } from \"@/registry/new-york/data-table/type-utils\";\nimport { useCallback, useState } from \"react\";\n\nexport const useFilters = <T extends object, K extends keyof T = keyof T>() => {\n   const [filters, setFilters] = useState<Record<K, T[K]>>();\n   const setFilter = useCallback(\n      (key: K, value: T[K] | undefined) => {\n         if (value === undefined) {\n            setFilters((prev) =>\n               prev\n                  ? (omitFields(prev ?? {}, [key]) as Record<K, T[K]>)\n                  : undefined\n            );\n         } else {\n            setFilters(\n               (prev) =>\n                  ({\n                     ...prev,\n                     [key]: value,\n                  } as Record<K, T[K]>)\n            );\n         }\n      },\n      [setFilters]\n   );\n\n   const getFilter = useCallback(\n      (key: K) => {\n         if (filters) {\n            return filters[key];\n         }\n         return undefined;\n      },\n      [filters]\n   );\n\n   return { filters, getFilter, setFilter };\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/data-table/use-sorting.ts",
      "content": "import { useCallback, useState } from \"react\";\n\nexport const useSorting = <T extends object>(initialSortColumn?: keyof T) => {\n   const [sortColumn, setSortColumn] = useState<\n      [keyof T, \"asc\" | \"desc\"] | undefined\n   >(() => (initialSortColumn ? [initialSortColumn, \"asc\"] : undefined));\n\n   const toggleSort = useCallback(\n      (column: keyof T) => {\n         setSortColumn((pair) => {\n            if (pair) {\n               const [key, dir] = pair;\n               if (key === column) {\n                  return [key, dir === \"asc\" ? \"desc\" : \"asc\"];\n               }\n            }\n            return [column, \"asc\"];\n         });\n      },\n      [setSortColumn]\n   );\n\n   const getSortDirection = useCallback(\n      (column: keyof T) => {\n         if (sortColumn) {\n            const [key, dir] = sortColumn;\n            return key === column ? { dir } : undefined;\n         }\n         return undefined;\n      },\n      [sortColumn]\n   );\n\n   return { sortColumn, toggleSort, getSortDirection };\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/data-table/data-table-utils.ts",
      "content": "export function defaultSortFn<T>(a: T[keyof T], b: T[keyof T]) {\n  if (a === b) return 0;\n  if (a == null) return -1;\n  if (b == null) return 1;\n\n  return a < b ? -1 : 1;\n}\n\nexport function defaultFilterFn<T>(a: T[keyof T], filter: T[keyof T]) {\n  if (!filter) return true;\n  if (typeof a === \"string\" && typeof filter === \"string\") {\n    return a.toLowerCase() === filter.toLowerCase();\n  }\n  return a === filter;\n}\n\nexport function startsWithFilterFn(a: string, filter: string) {\n  if (!filter) return true;\n  return a.toLowerCase().startsWith(filter.toLowerCase());\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function doGroupBy<T extends Record<string, any>, K extends keyof T>(\n  array: T[],\n  key: K,\n): [string, T[]][] {\n  return Object.entries(\n    array.reduce(\n      (acc, item) => {\n        const groupKey = item[key];\n        if (!acc[groupKey]) {\n          acc[groupKey] = [];\n        }\n        acc[groupKey].push(item);\n        return acc;\n      },\n      {} as Record<T[K], T[]>,\n    ),\n  );\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/data-table/text-utils.ts",
      "content": "export function capitalize(str: string) {\n   return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/data-table/type-utils.ts",
      "content": "export function omitFields<T extends object, K extends keyof T>(\n   obj: T,\n   keysToRemove: readonly K[]\n): Omit<T, K> {\n   const newObj = { ...obj };\n   for (const key of keysToRemove) {\n      delete newObj[key];\n   }\n   return newObj;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/data-table/data-table-types.d.ts",
      "content": "export type StyleOptions = {\n   container?: string;\n   table?: string;\n   headerRow?: string;\n   headerCell?: string;\n   bodyRow?: string;\n   bodyEvenRow?: string;\n   bodyOddRow?: string;\n   bodyCell?: string;\n   cellPadding?: number;\n   groupByRow?: string;\n   groupByCell?: string;\n   secondaryRow?: string;\n   secondaryCell?: string;\n   footerRow?: string;\n   footerCell?: string;\n};\n\nexport type GroupByRenderer<T extends object> = (\n   key: keyof T,\n   rows: T[]\n) => { className?: string; node: React.ReactNode }[];\n\nexport type FooterRenderer<T extends object> = (\n   rows: T[]\n) => { className?: string; node?: React.ReactNode }[];\n\nexport type SecondaryRowRenderer<T extends object> = (\n   row: T\n) => React.ReactNode;\n\ntype _ColumnDef<T extends object, K extends keyof T = keyof T> = {\n   accessorKey: K;\n   header?: string | React.ReactNode;\n   cell?: ({ row }: { row: T }) => React.ReactNode;\n   size?: number;\n   align?: \"center\" | \"left\" | \"right\";\n   sortable?: boolean;\n   sortButtonClassName?: string;\n   sortFn?: (a: T[K], b: T[K]) => number;\n   filterFn?: ((value: T[K], filter: T[K]) => boolean) | \"startsWith\";\n   headerClassName?: string;\n   cellClassName?: string;\n};\n\nexport type ColumnDef<T extends object> = {\n   [K in keyof T]-?: _ColumnDef<T, K>;\n}[keyof T];\n",
      "type": "registry:component",
      "target": "components/data-table/data-table-types.d.ts"
    }
  ]
}